import { merge } from './merge';
describe('merge', function () {
    it('can merge', function () {
        expect(merge({}, { a: 1, b: 0 }, { b: 2 })).toEqual({
            a: 1,
            b: 2,
        });
    });
    it('can handle falsey', function () {
        expect(merge({}, null, undefined, false, { a: '1' }, { b: '2' }, { b: undefined })).toEqual({
            a: '1',
            b: undefined,
        });
    });
    it('can handle null values', function () {
        expect(merge({}, { a: null })).toEqual({
            a: null,
        });
    });
    it('can handle array values', function () {
        expect(merge({}, { a: [1, 2] })).toEqual({ a: [1, 2] });
    });
    it('can merge deeply', function () {
        expect(merge({}, { b: 0 }, { a: { c: 1 } }, { a: { c: 2 } })).toEqual({
            a: { c: 2 },
            b: 0,
        });
    });
    it('can handle cycles', function () {
        var obj = {
            foo: undefined,
        };
        obj.foo = obj;
        expect(merge({}, obj)).toEqual({ foo: obj });
    });
    it('can handle deep cycles', function () {
        var obj = {
            foo: {
                bar: {
                    baz: undefined,
                },
            },
        };
        obj.foo.bar.baz = obj;
        var result = merge({}, obj);
        expect(result).toEqual({ foo: { bar: { baz: obj } } });
        expect(result.foo).not.toBe(obj.foo);
        expect(result.foo.bar.baz).toBe(obj);
    });
    it('can handle prototype pollution', function () {
        var obj1 = {
            __proto__: { payload: 'malicious value' },
            constructor: { foo: 'malicious value' },
        };
        // used to check it keeps other properties
        var obj2 = {
            __proto__: { payload: 'malicious value' },
            prototype: { payload: 'malicious value' },
            constructor: { foo: 'malicious value' },
            foo: { bar: 'baz' },
        };
        // used to check deep cycles
        var obj3 = {
            __proto__: { payload: 'malicious value' },
            constructor: { foo: 'malicious value' },
            a: { b: 'baz', __proto__: { payload: 'malicious value' } },
        };
        expect(merge({}, obj1)).toEqual({});
        expect(merge({}, obj2)).toEqual({ foo: { bar: 'baz' } });
        expect(merge({}, obj1, obj2)).toEqual({ foo: { bar: 'baz' } });
        // Checking that merge keeps target properties but doesn't merge malicious properties
        expect(merge(obj1, obj2, obj3)).toEqual({
            a: { b: 'baz' },
            constructor: { foo: 'malicious value' },
            foo: { bar: 'baz' },
        });
    });
});
//# sourceMappingURL=merge.test.js.map