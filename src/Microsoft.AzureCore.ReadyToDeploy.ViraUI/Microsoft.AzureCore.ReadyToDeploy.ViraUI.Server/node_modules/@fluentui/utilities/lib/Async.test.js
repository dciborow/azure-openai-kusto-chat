import { Async } from './Async';
describe('Async', function () {
    describe('debounce', function () {
        // Increase count by a specific number, to test the arguments
        // of the debounced function;
        var callCount = 0;
        var fnMock = function (increaseCount) {
            callCount += increaseCount;
            return callCount;
        };
        var fn;
        var async;
        var debouncedFn;
        beforeEach(function () {
            jest.useFakeTimers();
            fn = jest.fn(fnMock);
            async = new Async();
            debouncedFn = async.debounce(fn, 100);
        });
        afterEach(function () {
            callCount = 0;
            fn.mockClear();
        });
        it('should debounce multiple calls', function () {
            // Mock Date.now to return each call
            // First one is the first debouncedFn(1)
            // Second one is debouncedFn(2)
            // A last one will be when the timer fires after we run pending timers in jest.
            var dateMock = jest
                .spyOn(Date, 'now')
                .mockImplementationOnce(function () { return 10; })
                .mockImplementationOnce(function () { return 11; })
                .mockImplementation(function () { return 2000; });
            debouncedFn(1);
            expect(debouncedFn.pending()).toBeTruthy();
            debouncedFn(2);
            expect(debouncedFn.pending()).toBeTruthy();
            jest.runOnlyPendingTimers();
            expect(fn).toHaveBeenCalledTimes(1);
            expect(callCount).toEqual(2);
            dateMock.mockRestore();
        });
        it('should flush the last value', function () {
            debouncedFn(10);
            debouncedFn(20);
            expect(debouncedFn.pending()).toBeTruthy();
            expect(debouncedFn.flush()).toEqual(20);
        });
        it('should be marked pending as expected', function () {
            debouncedFn(100);
            expect(debouncedFn.pending()).toBeTruthy();
            debouncedFn(200);
            expect(debouncedFn.pending()).toBeTruthy();
            debouncedFn.flush();
            expect(debouncedFn.pending()).toBeFalsy();
        });
        it('should be cancellable', function () {
            debouncedFn(1000);
            debouncedFn.cancel();
            expect(debouncedFn.pending()).toBeFalsy();
            expect(debouncedFn.flush()).toBeUndefined();
        });
    });
    describe('throttle', function () {
        it('should throttle multiple calls', function () {
            jest.useFakeTimers();
            // Mock Date.now to return each call
            // First one is the first throttledFn(1)
            // Second one is throttledFn(2)
            // A last one will be when the timer fires after we run pending timers in jest.
            var dateMock = jest
                .spyOn(Date, 'now')
                .mockImplementationOnce(function () { return 10; })
                .mockImplementationOnce(function () { return 11; })
                .mockImplementation(function () { return 2000; });
            var fn = jest.fn(function (num) { return num; });
            var async = new Async();
            var throttledFn = async.throttle(fn, 1000);
            var result = throttledFn(1);
            expect(result).toBeUndefined();
            result = throttledFn(2);
            expect(result).toBeUndefined();
            jest.runOnlyPendingTimers();
            expect(fn).toHaveBeenCalledTimes(1);
            dateMock.mockRestore();
            jest.useRealTimers();
        });
    });
});
//# sourceMappingURL=Async.test.js.map