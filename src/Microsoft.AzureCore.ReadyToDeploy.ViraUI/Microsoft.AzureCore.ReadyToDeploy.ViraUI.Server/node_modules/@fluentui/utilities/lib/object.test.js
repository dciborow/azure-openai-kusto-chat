import { __assign } from "tslib";
import { assign, filteredAssign, mapEnumByName, values, omit, shallowCompare } from './object';
describe('shallowCompare', function () {
    it('returns true for matching objects', function () {
        var a = {
            a: 1,
            b: 'string',
            c: {
                d: 2,
            },
        };
        var b = __assign({}, a);
        expect(shallowCompare(a, b)).toBeTruthy();
    });
    it('returns false when one object is a superset of the other', function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var a = {
            a: 1,
            b: 'string',
            c: {
                d: 2,
            },
        };
        var b = __assign(__assign({}, a), { e: 'extra' });
        expect(shallowCompare(a, b)).toBeFalsy();
        a.e = 'extra';
        a.f = 3;
        expect(shallowCompare(a, b)).toBeFalsy();
    });
    it('returns false when nested objects are not strictly equal', function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var a = {
            a: 1,
            b: 'string',
            c: {
                d: 2,
            },
        };
        var b = __assign(__assign({}, a), { c: __assign({}, a.c) });
        expect(shallowCompare(a, b)).toBeFalsy();
    });
    it('returns true for two empty objects', function () {
        expect(shallowCompare({}, {})).toBeTruthy();
    });
    it('returns true for two falsy values', function () {
        expect(shallowCompare(null, null)).toBeTruthy();
        expect(shallowCompare(undefined, undefined)).toBeTruthy();
        expect(shallowCompare(null, undefined)).toBeTruthy();
        expect(shallowCompare(0, '')).toBeTruthy();
        expect(shallowCompare(null, '')).toBeTruthy();
        expect(shallowCompare(0, undefined)).toBeTruthy();
    });
    it('returns false when comparing null or undefined against an object', function () {
        expect(shallowCompare(null, { a: 1 })).toBeFalsy();
        expect(shallowCompare(undefined, { a: 1 })).toBeFalsy();
    });
});
describe('assign', function () {
    it('can copy an object', function () {
        var source = {
            a: 1,
            b: 'string',
            c: {
                d: 2,
            },
        };
        var resultTarget = {};
        var result = assign(resultTarget, source);
        expect(result).not.toBe(source);
        expect(result).toBe(resultTarget);
        expect(result).toEqual(source);
    });
});
describe('filteredAssign', function () {
    it('can copy an object but avoid copying some parameters', function () {
        var source = {
            a: 1,
            b: 'string',
        };
        var result = filteredAssign(function (propName) { return propName !== 'b'; }, {}, source);
        expect(result.a).toEqual(1);
        expect(result.b).toBeUndefined();
    });
});
describe('mapEnumByName', function () {
    it('iterates over all the strings of an enum', function () {
        var Foo;
        (function (Foo) {
            Foo[Foo["first"] = 0] = "first";
            Foo[Foo["second"] = 1] = "second";
            Foo[Foo["third"] = 2] = "third";
            Foo[Foo["fourth"] = 3] = "fourth";
        })(Foo || (Foo = {}));
        var result = mapEnumByName(Foo, function (name) {
            return name;
        });
        expect(result).toEqual(['first', 'second', 'third', 'fourth']);
    });
    it('filters undefined values', function () {
        var Foo;
        (function (Foo) {
            Foo[Foo["first"] = 0] = "first";
            Foo[Foo["second"] = 1] = "second";
            Foo[Foo["third"] = 2] = "third";
            Foo[Foo["fourth"] = 3] = "fourth";
        })(Foo || (Foo = {}));
        var result = mapEnumByName(Foo, function (name) {
            if (name === 'first' || name === 'third') {
                return name;
            }
            if (name === 'second') {
                return undefined;
            }
            return null;
        });
        expect(result).toEqual(['first', 'third']);
    });
});
describe('values', function () {
    it('gets all values in a dictionary object', function () {
        var obj = {
            test: 1,
            ing: 2,
            '123': 3,
        };
        var objValues = values(obj);
        expect(objValues).toHaveLength(3);
        expect(objValues).toContain(1);
        expect(objValues).toContain(2);
        expect(objValues).toContain(3);
    });
});
describe('omit', function () {
    it('can omit excluded props and leave non-excluded alone', function () {
        expect(omit({ a: 1, b: 2 }, ['a'])).toEqual({ b: 2 });
    });
});
//# sourceMappingURL=object.test.js.map