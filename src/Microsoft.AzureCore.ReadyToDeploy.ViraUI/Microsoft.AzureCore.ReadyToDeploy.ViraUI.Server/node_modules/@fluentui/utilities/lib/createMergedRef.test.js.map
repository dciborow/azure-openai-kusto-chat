{"version":3,"file":"createMergedRef.test.js","sourceRoot":"../src/","sources":["createMergedRef.test.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AACpD,OAAO,EAAE,KAAK,EAAE,MAAM,QAAQ,CAAC;AAE/B,QAAQ,CAAC,iBAAiB,EAAE;IAC1B,EAAE,CAAC,gBAAgB,EAAE;QACnB,IAAM,IAAI,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;QAC/C;YAAkB,uBAAuD;YAAzE;gBAAA,qEAMC;gBALS,eAAS,GAAG,eAAe,EAAkB,CAAC;;YAKxD,CAAC;YAHQ,oBAAM,GAAb;gBACE,OAAO,6BAAK,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,GAAI,CAAC;YAC/D,CAAC;YACH,UAAC;QAAD,CAAC,AAND,CAAkB,KAAK,CAAC,SAAS,GAMhC;QACD,IAAM,IAAI,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;QAC/C,IAAM,OAAO,GAAG,KAAK,CAAC,oBAAC,GAAG,IAAC,MAAM,EAAE,IAAI,GAAI,CAAC,CAAC;QAE7C,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,CAAC;QAClC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,CAAC;QAElC,OAAO,CAAC,OAAO,EAAE,CAAC;QAElB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC;QAChC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC;IAClC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,uDAAuD,EAAE;QAC1D,IAAM,SAAS,GAAG,eAAe,EAAE,CAAC;QAEpC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;IACxC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,iDAAiD,EAAE;QACpD,IAAM,SAAS,GAAG,eAAe,EAAE,CAAC;QAEpC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;IACjE,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import * as React from 'react';\nimport { createMergedRef } from './createMergedRef';\nimport { mount } from 'enzyme';\n\ndescribe('createMergedRef', () => {\n  it('can merge refs', () => {\n    const ref1 = React.createRef<HTMLDivElement>();\n    class Foo extends React.Component<{ domRef?: React.Ref<HTMLDivElement> }> {\n      private mergedRef = createMergedRef<HTMLDivElement>();\n\n      public render() {\n        return <div ref={this.mergedRef(this.props.domRef, ref1)} />;\n      }\n    }\n    const ref2 = React.createRef<HTMLDivElement>();\n    const wrapper = mount(<Foo domRef={ref2} />);\n\n    expect(ref1.current).toBeTruthy();\n    expect(ref2.current).toBeTruthy();\n\n    wrapper.unmount();\n\n    expect(ref1.current).toBeNull();\n    expect(ref2.current).toBeNull();\n  });\n\n  it('returns the same ref object with the same input twice', () => {\n    const mergedRef = createMergedRef();\n\n    expect(mergedRef()).toBe(mergedRef());\n  });\n\n  it('should return a new resolver if the refs change', () => {\n    const mergedRef = createMergedRef();\n\n    expect(mergedRef(null)).not.toBe(mergedRef(React.createRef()));\n  });\n});\n"]}