define(["require", "exports", "tslib", "./object"], function (require, exports, tslib_1, object_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('shallowCompare', function () {
        it('returns true for matching objects', function () {
            var a = {
                a: 1,
                b: 'string',
                c: {
                    d: 2,
                },
            };
            var b = tslib_1.__assign({}, a);
            expect((0, object_1.shallowCompare)(a, b)).toBeTruthy();
        });
        it('returns false when one object is a superset of the other', function () {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var a = {
                a: 1,
                b: 'string',
                c: {
                    d: 2,
                },
            };
            var b = tslib_1.__assign(tslib_1.__assign({}, a), { e: 'extra' });
            expect((0, object_1.shallowCompare)(a, b)).toBeFalsy();
            a.e = 'extra';
            a.f = 3;
            expect((0, object_1.shallowCompare)(a, b)).toBeFalsy();
        });
        it('returns false when nested objects are not strictly equal', function () {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var a = {
                a: 1,
                b: 'string',
                c: {
                    d: 2,
                },
            };
            var b = tslib_1.__assign(tslib_1.__assign({}, a), { c: tslib_1.__assign({}, a.c) });
            expect((0, object_1.shallowCompare)(a, b)).toBeFalsy();
        });
        it('returns true for two empty objects', function () {
            expect((0, object_1.shallowCompare)({}, {})).toBeTruthy();
        });
        it('returns true for two falsy values', function () {
            expect((0, object_1.shallowCompare)(null, null)).toBeTruthy();
            expect((0, object_1.shallowCompare)(undefined, undefined)).toBeTruthy();
            expect((0, object_1.shallowCompare)(null, undefined)).toBeTruthy();
            expect((0, object_1.shallowCompare)(0, '')).toBeTruthy();
            expect((0, object_1.shallowCompare)(null, '')).toBeTruthy();
            expect((0, object_1.shallowCompare)(0, undefined)).toBeTruthy();
        });
        it('returns false when comparing null or undefined against an object', function () {
            expect((0, object_1.shallowCompare)(null, { a: 1 })).toBeFalsy();
            expect((0, object_1.shallowCompare)(undefined, { a: 1 })).toBeFalsy();
        });
    });
    describe('assign', function () {
        it('can copy an object', function () {
            var source = {
                a: 1,
                b: 'string',
                c: {
                    d: 2,
                },
            };
            var resultTarget = {};
            var result = (0, object_1.assign)(resultTarget, source);
            expect(result).not.toBe(source);
            expect(result).toBe(resultTarget);
            expect(result).toEqual(source);
        });
    });
    describe('filteredAssign', function () {
        it('can copy an object but avoid copying some parameters', function () {
            var source = {
                a: 1,
                b: 'string',
            };
            var result = (0, object_1.filteredAssign)(function (propName) { return propName !== 'b'; }, {}, source);
            expect(result.a).toEqual(1);
            expect(result.b).toBeUndefined();
        });
    });
    describe('mapEnumByName', function () {
        it('iterates over all the strings of an enum', function () {
            var Foo;
            (function (Foo) {
                Foo[Foo["first"] = 0] = "first";
                Foo[Foo["second"] = 1] = "second";
                Foo[Foo["third"] = 2] = "third";
                Foo[Foo["fourth"] = 3] = "fourth";
            })(Foo || (Foo = {}));
            var result = (0, object_1.mapEnumByName)(Foo, function (name) {
                return name;
            });
            expect(result).toEqual(['first', 'second', 'third', 'fourth']);
        });
        it('filters undefined values', function () {
            var Foo;
            (function (Foo) {
                Foo[Foo["first"] = 0] = "first";
                Foo[Foo["second"] = 1] = "second";
                Foo[Foo["third"] = 2] = "third";
                Foo[Foo["fourth"] = 3] = "fourth";
            })(Foo || (Foo = {}));
            var result = (0, object_1.mapEnumByName)(Foo, function (name) {
                if (name === 'first' || name === 'third') {
                    return name;
                }
                if (name === 'second') {
                    return undefined;
                }
                return null;
            });
            expect(result).toEqual(['first', 'third']);
        });
    });
    describe('values', function () {
        it('gets all values in a dictionary object', function () {
            var obj = {
                test: 1,
                ing: 2,
                '123': 3,
            };
            var objValues = (0, object_1.values)(obj);
            expect(objValues).toHaveLength(3);
            expect(objValues).toContain(1);
            expect(objValues).toContain(2);
            expect(objValues).toContain(3);
        });
    });
    describe('omit', function () {
        it('can omit excluded props and leave non-excluded alone', function () {
            expect((0, object_1.omit)({ a: 1, b: 2 }, ['a'])).toEqual({ b: 2 });
        });
    });
});
//# sourceMappingURL=object.test.js.map