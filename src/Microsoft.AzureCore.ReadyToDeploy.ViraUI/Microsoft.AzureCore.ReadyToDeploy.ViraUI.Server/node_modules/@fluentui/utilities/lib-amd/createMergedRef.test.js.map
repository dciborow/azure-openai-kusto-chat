{"version":3,"file":"createMergedRef.test.js","sourceRoot":"../src/","sources":["createMergedRef.test.tsx"],"names":[],"mappings":";;;IAIA,QAAQ,CAAC,iBAAiB,EAAE;QAC1B,EAAE,CAAC,gBAAgB,EAAE;YACnB,IAAM,IAAI,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;YAC/C;gBAAkB,+BAAuD;gBAAzE;oBAAA,qEAMC;oBALS,eAAS,GAAG,IAAA,iCAAe,GAAkB,CAAC;;gBAKxD,CAAC;gBAHQ,oBAAM,GAAb;oBACE,OAAO,6BAAK,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,GAAI,CAAC;gBAC/D,CAAC;gBACH,UAAC;YAAD,CAAC,AAND,CAAkB,KAAK,CAAC,SAAS,GAMhC;YACD,IAAM,IAAI,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;YAC/C,IAAM,OAAO,GAAG,IAAA,cAAK,EAAC,oBAAC,GAAG,IAAC,MAAM,EAAE,IAAI,GAAI,CAAC,CAAC;YAE7C,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,CAAC;YAClC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,CAAC;YAElC,OAAO,CAAC,OAAO,EAAE,CAAC;YAElB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC;YAChC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC;QAClC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,uDAAuD,EAAE;YAC1D,IAAM,SAAS,GAAG,IAAA,iCAAe,GAAE,CAAC;YAEpC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,iDAAiD,EAAE;YACpD,IAAM,SAAS,GAAG,IAAA,iCAAe,GAAE,CAAC;YAEpC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;QACjE,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC","sourcesContent":["import * as React from 'react';\nimport { createMergedRef } from './createMergedRef';\nimport { mount } from 'enzyme';\n\ndescribe('createMergedRef', () => {\n  it('can merge refs', () => {\n    const ref1 = React.createRef<HTMLDivElement>();\n    class Foo extends React.Component<{ domRef?: React.Ref<HTMLDivElement> }> {\n      private mergedRef = createMergedRef<HTMLDivElement>();\n\n      public render() {\n        return <div ref={this.mergedRef(this.props.domRef, ref1)} />;\n      }\n    }\n    const ref2 = React.createRef<HTMLDivElement>();\n    const wrapper = mount(<Foo domRef={ref2} />);\n\n    expect(ref1.current).toBeTruthy();\n    expect(ref2.current).toBeTruthy();\n\n    wrapper.unmount();\n\n    expect(ref1.current).toBeNull();\n    expect(ref2.current).toBeNull();\n  });\n\n  it('returns the same ref object with the same input twice', () => {\n    const mergedRef = createMergedRef();\n\n    expect(mergedRef()).toBe(mergedRef());\n  });\n\n  it('should return a new resolver if the refs change', () => {\n    const mergedRef = createMergedRef();\n\n    expect(mergedRef(null)).not.toBe(mergedRef(React.createRef()));\n  });\n});\n"]}