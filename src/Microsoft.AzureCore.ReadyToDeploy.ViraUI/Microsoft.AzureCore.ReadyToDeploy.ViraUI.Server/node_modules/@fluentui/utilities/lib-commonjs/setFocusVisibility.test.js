"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var useFocusRects_1 = require("./useFocusRects");
var setFocusVisibility_1 = require("./setFocusVisibility");
var getWindow = require("./dom/getWindow");
var enzyme_1 = require("enzyme");
describe('setFocusVisibility', function () {
    var wrapper;
    var classNames = [];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var mockWindow = {
        addEventListener: function (name, callback) {
            mockWindow[name] = callback;
        },
        removeEventListener: function (name, callback) {
            if (mockWindow[name] === callback) {
                mockWindow[name] = undefined;
            }
        },
        document: {
            body: {
                classList: {
                    contains: function (name) { return classNames.indexOf(name) > -1; },
                    add: function (name) { return classNames.indexOf(name) < 0 && classNames.push(name); },
                    remove: function (name) { return classNames.indexOf(name) > -1 && classNames.splice(classNames.indexOf(name), 1); },
                    toggle: function (name, val) {
                        var hasClass = classNames.indexOf(name) > -1;
                        if (hasClass !== val) {
                            if (hasClass) {
                                classNames.splice(classNames.indexOf(name), 1);
                            }
                            else {
                                classNames.push(name);
                            }
                        }
                    },
                },
            },
        },
    };
    var mockTarget = {
        ownerDocument: {
            defaultView: mockWindow,
        },
    };
    beforeEach(function () {
        jest.spyOn(getWindow, 'getWindow').mockReturnValue(mockWindow);
        classNames = [];
        wrapper = (0, enzyme_1.mount)(React.createElement(useFocusRects_1.FocusRects, null));
    });
    afterEach(function () { return wrapper.unmount(); });
    it('hints to show focus', function () {
        (0, setFocusVisibility_1.setFocusVisibility)(true);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusHiddenClassName) > -1).toEqual(false);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusVisibleClassName) > -1).toEqual(true);
    });
    it('hints to hide focus', function () {
        (0, setFocusVisibility_1.setFocusVisibility)(true);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusHiddenClassName) > -1).toEqual(false);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusVisibleClassName) > -1).toEqual(true);
        (0, setFocusVisibility_1.setFocusVisibility)(false);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusHiddenClassName) > -1).toEqual(true);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusVisibleClassName) > -1).toEqual(false);
    });
    it('hints to show focus with target specified', function () {
        (0, setFocusVisibility_1.setFocusVisibility)(true, mockTarget);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusHiddenClassName) > -1).toEqual(false);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusVisibleClassName) > -1).toEqual(true);
    });
    it('hints to hide focus with target specified', function () {
        (0, setFocusVisibility_1.setFocusVisibility)(true, mockTarget);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusHiddenClassName) > -1).toEqual(false);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusVisibleClassName) > -1).toEqual(true);
        (0, setFocusVisibility_1.setFocusVisibility)(false, mockTarget);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusHiddenClassName) > -1).toEqual(true);
        expect(classNames.indexOf(setFocusVisibility_1.IsFocusVisibleClassName) > -1).toEqual(false);
    });
});
//# sourceMappingURL=setFocusVisibility.test.js.map