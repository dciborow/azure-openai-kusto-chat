"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var warn_1 = require("./warn");
var warnConditionallyRequiredProps_1 = require("./warnConditionallyRequiredProps");
var warnMutuallyExclusive_1 = require("./warnMutuallyExclusive");
var warnDeprecations_1 = require("./warnDeprecations");
var warningCallback = jest.fn();
function sharedBeforeEach() {
    (0, warn_1.setWarningCallback)(warningCallback);
}
function sharedAfterEach() {
    warningCallback.mockReset();
    (0, warn_1.setWarningCallback)(undefined);
}
describe('warnDeprecations', function () {
    beforeEach(sharedBeforeEach);
    afterEach(sharedAfterEach);
    it('does not warn when unnecessary', function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (0, warnDeprecations_1.warnDeprecations)('Foo', { bar: 1 }, { foo: null });
        expect(warningCallback).not.toHaveBeenCalled();
    });
    it('can warn on a deprecated prop', function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (0, warnDeprecations_1.warnDeprecations)('Foo', { foo: 1 }, { foo: null });
        expect(warningCallback).toHaveBeenCalledTimes(1);
        expect(warningCallback).toHaveBeenLastCalledWith("Foo property 'foo' was used but has been deprecated.");
    });
    it('can warn on a deprecated prop with replacement', function () {
        (0, warnDeprecations_1.warnDeprecations)('Foo', { foo: 1 }, { foo: 'bar' });
        expect(warningCallback).toHaveBeenCalledTimes(1);
        expect(warningCallback).toHaveBeenLastCalledWith("Foo property 'foo' was used but has been deprecated. Use 'bar' instead.");
    });
});
describe('warnMutuallyExclusive', function () {
    beforeEach(sharedBeforeEach);
    afterEach(sharedAfterEach);
    it('does not warn when unnecessary', function () {
        (0, warnMutuallyExclusive_1.warnMutuallyExclusive)('Foo', { foo: 1 }, { foo: 'bar' });
        expect(warningCallback).not.toHaveBeenCalled();
    });
    it('does not warn unnecessarily when the key of the exclusive map is explicitly undefined', function () {
        (0, warnMutuallyExclusive_1.warnMutuallyExclusive)('Foo', { foo: undefined, bar: 1 }, { foo: 'bar' });
        expect(warningCallback).not.toHaveBeenCalled();
    });
    it('does not warn unnecessarily when the matching prop of the exclusive map key is explicitly undefined', function () {
        (0, warnMutuallyExclusive_1.warnMutuallyExclusive)('Foo', { foo: 1, bar: undefined }, { foo: 'bar' });
        expect(warningCallback).not.toHaveBeenCalled();
    });
    it('does not warn unnecessarily when both of them are explicitly undefined', function () {
        (0, warnMutuallyExclusive_1.warnMutuallyExclusive)('Foo', { foo: undefined, bar: undefined }, { foo: 'bar' });
        expect(warningCallback).not.toHaveBeenCalled();
    });
    it('does not warn unnecessarily when the key of the exclusive map is implicitly undefined', function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (0, warnMutuallyExclusive_1.warnMutuallyExclusive)('Foo', { bar: 1 }, { foo: 'bar' });
        expect(warningCallback).not.toHaveBeenCalled();
    });
    it('does not warn unnecessarily when the matching prop of the exclusive map is implicitly undefined', function () {
        (0, warnMutuallyExclusive_1.warnMutuallyExclusive)('Foo', { foo: 1 }, { foo: 'bar' });
        expect(warningCallback).not.toHaveBeenCalled();
    });
    it('does not warn unnecessarily when both of the props are implicitly undefined ', function () {
        (0, warnMutuallyExclusive_1.warnMutuallyExclusive)('Foo', {}, {});
        expect(warningCallback).not.toHaveBeenCalled();
    });
    it('can warn on mutual exclusive props', function () {
        (0, warnMutuallyExclusive_1.warnMutuallyExclusive)('Foo', { foo: 1, bar: 1 }, { foo: 'bar' });
        expect(warningCallback).toHaveBeenCalledTimes(1);
        expect(warningCallback).toHaveBeenLastCalledWith("Foo property 'foo' is mutually exclusive with 'bar'. Use one or the other.");
    });
    it('can warn if the exclusive props with the key in the map is null', function () {
        (0, warnMutuallyExclusive_1.warnMutuallyExclusive)('Foo', { foo: null, bar: 1 }, { foo: 'bar' });
        expect(warningCallback).toHaveBeenCalledTimes(1);
        expect(warningCallback).toHaveBeenLastCalledWith("Foo property 'foo' is mutually exclusive with 'bar'. Use one or the other.");
    });
    it('can warn if the matching key in exclusive map is null', function () {
        (0, warnMutuallyExclusive_1.warnMutuallyExclusive)('Foo', { foo: 1, bar: null }, { foo: 'bar' });
        expect(warningCallback).toHaveBeenCalledTimes(1);
        expect(warningCallback).toHaveBeenLastCalledWith("Foo property 'foo' is mutually exclusive with 'bar'. Use one or the other.");
    });
    it('can warn if both of the props are null', function () {
        (0, warnMutuallyExclusive_1.warnMutuallyExclusive)('Foo', { foo: null, bar: null }, { foo: 'bar' });
        expect(warningCallback).toHaveBeenCalledTimes(1);
        expect(warningCallback).toHaveBeenLastCalledWith("Foo property 'foo' is mutually exclusive with 'bar'. Use one or the other.");
    });
});
describe('warnConditionallyRequiredProps', function () {
    beforeEach(sharedBeforeEach);
    afterEach(sharedAfterEach);
    it('does not warn when unnecessary', function () {
        (0, warnConditionallyRequiredProps_1.warnConditionallyRequiredProps)('Foo', { foo: 1, bar: 1 }, ['foo', 'bar'], 'foo', true);
        expect(warningCallback).not.toHaveBeenCalled();
    });
    it('can warn on required props', function () {
        (0, warnConditionallyRequiredProps_1.warnConditionallyRequiredProps)('Foo', { foo: 1 }, ['foo', 'bar'], 'foo', true);
        expect(warningCallback).toHaveBeenCalledTimes(1);
        expect(warningCallback).toHaveBeenLastCalledWith("Foo property 'bar' is required when 'foo' is used.'");
    });
});
//# sourceMappingURL=warn.test.js.map