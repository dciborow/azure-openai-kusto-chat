{"version":3,"file":"getParent.js","sourceRoot":"../src/","sources":["getParent.ts"],"names":[],"mappings":";;;AAAA,uDAAsD;AACtD;;;;;;GAMG;AACH,SAAgB,SAAS,CAAC,KAAkB,EAAE,mBAAmC;;IAAnC,oCAAA,EAAA,0BAAmC;IAC/E,IAAI,CAAC,KAAK,EAAE;QACV,OAAO,IAAI,CAAC;KACb;IAED,IAAM,MAAM,GAAG,mBAAmB,IAAI,IAAA,mCAAgB,EAAC,KAAK,CAAC,CAAC;IAE9D,IAAI,MAAM,EAAE;QACV,OAAO,MAAM,CAAC;KACf;IAED,4CAA4C;IAC5C,IAAI,OAAQ,KAAyB,CAAC,gBAAgB,KAAK,UAAU,KAAI,MAAA,KAAK,CAAC,YAAY,0CAAE,UAAU,CAAA,EAAE;QACvG,qBAAqB;QACrB,OAAO,KAAK,CAAC,YAA2B,CAAC;KAC1C;SAAM,IAAI,CAAA,MAAA,KAAK,CAAC,UAAU,0CAAE,QAAQ,MAAK,EAAE,EAAE;QAC5C,mCAAmC;QACnC,4BAA4B;QAC5B,OAAQ,KAAK,CAAC,UAAyB,CAAC,IAAmB,CAAC;KAC7D;SAAM;QACL,OAAO,KAAK,CAAC,UAAyB,CAAC;KACxC;AACH,CAAC;AAtBD,8BAsBC","sourcesContent":["import { getVirtualParent } from './getVirtualParent';\n/**\n * Gets the element which is the parent of a given element.\n * If `allowVirtuaParents` is `true`, this method prefers the virtual parent over\n * real DOM parent when present.\n *\n * @public\n */\nexport function getParent(child: HTMLElement, allowVirtualParents: boolean = true): HTMLElement | null {\n  if (!child) {\n    return null;\n  }\n\n  const parent = allowVirtualParents && getVirtualParent(child);\n\n  if (parent) {\n    return parent;\n  }\n\n  // Support looking for parents in shadow DOM\n  if (typeof (child as HTMLSlotElement).assignedElements !== 'function' && child.assignedSlot?.parentNode) {\n    // Element is slotted\n    return child.assignedSlot as HTMLElement;\n  } else if (child.parentNode?.nodeType === 11) {\n    // nodeType 11 is DOCUMENT_FRAGMENT\n    // Element is in shadow root\n    return (child.parentNode as ShadowRoot).host as HTMLElement;\n  } else {\n    return child.parentNode as HTMLElement;\n  }\n}\n"]}